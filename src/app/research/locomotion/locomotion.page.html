<ion-header>
  <ion-toolbar>
    <ion-buttons slot="start">
      <ion-menu-button></ion-menu-button>
    </ion-buttons>
    <ion-title>Research</ion-title>
  </ion-toolbar>
</ion-header>

<ion-content>
  <ion-card>
    <ion-card-header>
      <ion-card-title style="font-size:2em;">Learning Locomotion using a Keyframe-based System</ion-card-title>
    </ion-card-header>
    <ion-card-content>
      <ion-card-subtitle style="font-size:1.5em;">Ethan Wilson</ion-card-subtitle>
      <ion-card-subtitle style="font-size:1.5em;">Greg Turk</ion-card-subtitle>
      <ion-card-subtitle style="font-size:1.5em;">Yunbo Zhang</ion-card-subtitle>
    </ion-card-content>
  </ion-card>
  <ion-card color="tertiary" button="true" href="assets/loco/draft.docx" download="draft.docx">
      <ion-card-content style="text-align:center;"><h2>Download Paper</h2></ion-card-content>
  </ion-card>

  <!-- 
TEMPLATE:

TEXT SECTION:

  <ion-card>
    <ion-card-header>
      <ion-card-title>SECTION_HEADER</ion-card-title>
    </ion-card-header>
    <ion-card-content>
PARAGRAPH_1
    </ion-card-content>
    <ion-card-content>
PARAGRAPH_2
    </ion-card-content>
    <ion-card-content>
PARAGRAPH_3
    </ion-card-content>
  </ion-card>

VIDEO:
  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/NAME.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

IMAGE:
  <ion-card color="tertiary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
	      <img style="height:100%;width:auto;display:block;margin-left:auto;margin-right:auto;" src="assets/loco/img/NAME.png" alt="" />
      </ion-card>
    </ion-card-content>
  </ion-card>

  -->

  <ion-card>
    <ion-card-header>
      <ion-card-title>Introduction</ion-card-title>
    </ion-card-header>
    <ion-card-content>
Animated motion of a digital character / model is derived from a few different methods which depend on the simulation environment.  Traditional animation, applied in video games, animated film, etc., keeps a record of keyframes, or values for the rotation of joints within  a model's underlying skeleton.  These keyframes correspond to different points in time, and the program interpolates between them to generate the animation.  These keyframes are typically either animated by hand or obtained through motion capture technology.  
    </ion-card-content>
    <ion-card-content>
Animations that must conform to the laws of physics, i.e. existing within physics simulations, must be animated in a different manner.  Real humans / creatures perform an infinite amount of subconscious motions to preserve balance and save energy, but it would take an exorbitant amount of time for a human animator to replicate those balance changes using keyframes in a physical simulation.  Without those corrections, realistic-looking animation loops might lose their stability over time, resulting in the agent falling over, and successfully human-animated motion would likely look robotic or simulated.
    </ion-card-content>
    <ion-card-content>
My goal was to create a physics-based animation system that could import custom models and generate stable walk cycles [i.e. completing multiple cycles without falling over, yet still moving in the forward direction] within an affordable amount of time. 
    </ion-card-content>
  </ion-card>

  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/quad_good_walk.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title>Related Work</ion-card-title>
    </ion-card-header>
    <ion-card-content>
Traditionally, the solution for animating with respect to physical constraints has been to employ some heuristic optimization algorithm.  Heuristic algorithms do not search for a single perfect solution; instead they approximate a solution that is "good enough" and can be found in a reasonable amount of time.  These algorithms are especially effective in locomotion because of the large problem space (there are infinite variations of acceptable forms of locomotion).  Evolutionary algorithms work particularly well as they tend to avoid local maxima and can indefinitely continue searching for a more efficient solution.  For example, Kodjabachian used an evolutionary approach to build a neural network controller for simulated two-dimensional insects.  These insects were able to learn locomotion and perform higher level behaviors, such as obstacle avoidance and an odor-gradient food detection system[1].
    </ion-card-content>
    <ion-card-content>
Recent improvements in computational technology have opened the gateway to apply more computationally expensive algorithms.  Reinforcement learning (RL), a subset of machine learning that balances an agent's environmental exploration vs. exploitation, has become an especially popular method.  There are various existing implementations of RL locomotion training, and some have extended functionality for various scenarios.  An example is Simbicon, a three-dimensional biped locomotion controller that incorporated the ability to react to varied terrain and outside forces[2].  However, these solutions remain too computationally expensive to perform without a dedicated setup.  While a research lab might be able to afford a week of training on a dedicated multi-GPU system, I am restricted to using a mid-range laptop.
    </ion-card-content>
  </ion-card>

  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/crab_run.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title>My Approach</ion-card-title>
    </ion-card-header>
    <ion-card-content>
My implementation used a Genetic Algorithm (GA), an evolutionary algorithm in which various DNA compete within a population that evolves over time.  In order to save computation time and limit the problem's search space, I opted to model my DNA after the keyframe system present in traditional animation.  Thus, my solution is prone to the problems animators face (discussed in the introduction), but it is able to achieve significantly more precise values than any human animator could. 
    </ion-card-content>
  </ion-card>

  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/tall_walk.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title>Skel Controller within DART</ion-card-title>
    </ion-card-header>
    <ion-card-content>
The physics simulation I chose to use was the Dynamic Animation and Robotics Toolkit (DART).  DART is an open-source library that was written at the Georgia Institute of Technology collaboratively by the Graphics Lab and Humanoid Robotics Lab[3].  I chose DART both because it is an ideal environment for simulating rigid body systems and because of my advisors' experience with the program.  
    </ion-card-content>
    <ion-card-content>
DART's functionality includes a customizable controller for every rigid body entity within the simulation.  This controller can be used to dynamically apply torque to the joints of the rigid body during the simulation's runtime.  The controller I implemented was an extension of the Stable Proportional-Derivative (SPD) controller[4].  In the context of a rigidbody system, a SPD controller provides stable tracking to a target pose.  This is achieved by applying a control force to the rigid body's joints, computed using the joint's current kinematics, the target position, and the simulation's timestep.  A proportional gain (tracking strength) and derivative gain (damping strength) are included in the equation used and can be changed to tweak the tracking intensity.  SPD controllers differ from traditional Proportional-Derivative (PD) controllers in their calculation; SPD use a computed estimate of the simulation's next time-step rather than the current time-step.  This method ensures stability when undergoing large motions or high time steps, whereas the traditional PD controller may break down.
    </ion-card-content>
    <ion-card-content>
My controller utilizes the SPD controller's computations for all torque calculations.  At the initialization phase of the simulation, my controller is fed a list of tracking poses.  Then, when applicable, these poses are mirrored and/or interpolated to generate a large cycle of poses for the controller to use.  
    </ion-card-content>
    <ion-card-content>
To mirror a pose, specific values within the pose (referred to as degrees of freedom, explained in-depth in a later section) that map from left to right are transferred to the opposite side, and vice versa.  The code to mirror depends on the model at hand.  Interpolation can be applied generally to any model.  To interpolate, two adjacent poses from within the loop are chosen.  Multiple intermediate poses are generated by linearly interpolating between the two chosen poses.  These generated poses are then added to a new list which ends up being much larger.  This process is repeated between each adjacent pair of poses, with the interpolated poses being added to the same new list, which finally replaces the initial list of poses.
    </ion-card-content>
    <ion-card-content>
At runtime, the controller tracks to a pose and constantly computes an error value between the model's current position and the pose being tracked.  Once this error drops beneath a specific value, the target pose shifts to the next pose in the list.  Using error to determine when to track a new pose differs from animation's traditional keyframe approach, where the tracking of keyframes are based completely on time.  My approach generated smoother motions than a linear time-based system would; additionally, this system discouraged unexpected behaviors by adding physical constraints to the rigidbody.  If a model was unable to reach its next pose (from falling over and being blocked by the ground, or any other reason), it would get stuck, whereas a strictly time-based keyframe system's model would ignore the fact that it was stuck and continue attempting to reach poses, resulting in unnatural, spastic motion.
    </ion-card-content>
  </ion-card>

  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/quad_mirror_pose.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title>Genetic Algorithm</ion-card-title>
    </ion-card-header>
    <ion-card-content>
A genetic algorithm (GA) is a framework for solving optimization problems which is based upon the process of natural selection found in biological evolution.  Different solutions to the problem, referred to as genomes, are initially randomly generated by the algorithm.  These genomes are stored in a list of fixed size known as the population.  The algorithm progresses by alternating between evolutionary and evaluation stages.  At each evaluation stage, every genome in the population is tested against a fitness function and given a score which corresponds to how effectively they have solved the problem.  The evolutionary stage typically involves a combination of crossover and mutation.  Crossover is a process in which two genomes, now known as the parents, are selected from the population and their information is combined to produce some number of children.  Mutation takes in a single genome sequence and slightly changes some of its values, creating a slightly different solution to the problem.  Crossover and mutations are performed on the population in an effort to produce better solutions that can be used in later generations.  At the end of each evolutionary stage, the population, which may contain extra DNA from crossover, must be culled back to its original size.
    </ion-card-content>
  </ion-card>

  <ion-card color="secondary">
    <ion-card-content>
      <ion-card color="dark" style="padding:10px">
      <video controls="controls" style="display:block;width:100%;height:auto;margin-left:auto;margin-right:auto;">
        <source src="assets/loco/video/crab_flipped.mp4" type="video/mp4">
      </video>
      </ion-card>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title>Data Storage</ion-card-title>
    </ion-card-header>
    <ion-card-content>
I chose to represent my DNA as a list of target poses for the controller within DART to use.  Every pose was a list of values, and each value corresponded to the rotation value of one degrees of freedom (DOF) within the model.  
    </ion-card-content>
    <ion-card-content>
A model is composed of various body sections, which are connected by joints.  There are multiple joint classifications to choose from, with the more complicated joint types having more DOFs.  A DOF is a single value that corresponds to one axis of rotation in the world (the axis can be of any orientation, however).  The types of joints are as follows:
    </ion-card-content>
      <ion-list color="tertiary" lines="none" style="margin:auto;width:80%;">
        <ion-item>
1.  Revolute joints contain one DOF.  An example would be a human’s elbow, which can only rotate along the bicep’s orientation.  Notice, however, that as the shoulder moves the elbow’s global rotation also changes, so the revolute joint’s constraint is only local to the body part it is placed on.
        </ion-item>
        <ion-item>
2.  Universal joints contain two DOFs.  An example is the human knee, which can rotate along the thigh’s orientation or rotate slightly along the calf’s axis.  It can not rotate all the way around the thigh due to having two axes of rotation in a 3D space.
        </ion-item>
        <ion-item>
3.  Euler joints contain three DOFs, and can rotate along all axes.  An example is the shoulder.  Notice that the shoulder still has value constraints.  It can rotate along every axis, but the extent of rotation is limited by the person’s flexibility.
        </ion-item>
        <ion-item>
4.  Free joints connect two separate objects and contain three DOFs for rotation and three DOFs for position.  These joints can not be directly manipulated and exist solely to inform the simulation.
        </ion-item>
        <ion-item>
5.  Weld joints have zero DOFs and rigidly connect two body parts.  These help to create more complex geometry by combining primitive shapes.
        </ion-item>
      </ion-list>
    <ion-card-content>
Limiting the number of DOFs on a model would decrease computation time, so models were created creatively to have the simplest combination of joints while still being able to achieve motion similar to the creatures they were modeled after.  In addition, I limited the values of these DOFs within the DNA to have a roughly 90 degree range.  This restriction acted similarly to a human shoulder in that without constraints, a shoulder would be able to clip into its attached body.  This helped to both keep movement natural and to decrease the problem’s search space significantly.
    </ion-card-content>
    <ion-card-content>
To save additional computation time, for symmetrical models I implemented a mirror system.  Each piece of DNA would only contain info for half of a walk cycle, which would then be mirrored over at the beginning of the evaluation phase.  This halved the amount of data in the GA, which exponentially decreased search time.  
    </ion-card-content>
  </ion-card>




</ion-content>
